<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mind Map – d3-force</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7" crossorigin="anonymous"></script>
  <style>
    :root {
      --bg: #131416;          /* very dark blue-gray */
      --panel: #121821;       /* slightly lighter than bg */
      --text: #e5e7eb;        /* gray-100 */
      --muted: #9aa3af;       /* gray-400 */
      --accent: #7dd3fc;      /* sky-300 */
      --link: #3b82f6;        /* blue-500 */
      --danger: #ef4444;      /* red-500 */
      --ok: #22c55e;          /* green-500 */
      --border: #1f2937;      /* gray-800 */
      --shadow: rgba(0,0,0,0.0);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
    .app { display: flex; flex-direction: column; height: 100%; }
    .toolbar { display:flex; align-items:center; gap:.5rem; padding:.6rem .8rem;position: sticky; top: 0; z-index: 2; }
    .toolbar button { background: var(--panel); color: var(--text); border: 1px solid var(--border); padding: .45rem .7rem; border-radius: .6rem; cursor: pointer; box-shadow: 0 2px 6px var(--shadow); }
    .toolbar button:hover { border-color: #334155; }
    .range-group{display:flex;align-items:center;gap:.4rem;margin-left:1rem}
    .range-group label{color:var(--muted);font-size:.85rem}
    .range-group input[type=range]{accent-color:var(--accent);width:140px}
    .content { flex: 1; min-height: 0; display: grid; grid-template-columns: 1fr !important; }
    .graph-wrap { position: relative; background: var(--bg); }
    .inspector { border-left: 1px solid var(--border); background: var(--panel); padding: 12px; display:flex; flex-direction:column; gap:.75rem; }
    .inspector h3 { margin: 0px 0 0; font-weight: 600; font-size: 1rem; letter-spacing: .02em; }
    .inspector .card { border: 0px solid var(--border); border-radius: .75rem; padding: .8rem; background: rgba(255,255,255,0.02); box-shadow: 0 8px 24px var(--shadow) inset; }
    .field { display: grid; grid-template-columns: 82px 1fr; align-items: center; gap:.5rem; margin:.35rem 0; }
    .field label { color: var(--muted); font-size: .85rem; }
    .field input, .field textarea { width: 100%; background: #0e141c; color: var(--text); border:1px solid var(--border); border-radius: .5rem; padding:.5rem .6rem; font-size:.95rem; }
    .field textarea { resize: vertical; min-height: 70px; }
    .row { display:flex; align-items:center; gap:.5rem; flex-wrap: wrap; }
    .badge { font-size: .75rem; padding:.2rem .45rem; border:1px solid var(--border); border-radius:.4rem; color: var(--muted); }
    .error { color: var(--danger); font-size: .9rem; }

    svg { width: 100%; height: 100%; display:block; cursor: grab; }
    svg:active { cursor: grabbing; }

    .link { stroke: #64748b; stroke-opacity: 0.9; stroke-width: 2px; }
    .link.highlight { stroke: var(--accent); stroke-opacity: .9; }
    .link-hot { stroke: transparent; stroke-width: 14px; pointer-events: stroke; }

    .node-g { cursor: move; }
    .node-rect { stroke: rgba(255,255,255,0.2); stroke-width: 1px; rx: 9px; ry: 9px; }
    .node-rect.selected { stroke: var(--accent); stroke-width: 2px; }

    .node-label { font-size: 12px; dominant-baseline: middle; text-anchor: middle; fill: var(--text); pointer-events: none; paint-order: stroke; stroke: rgba(0,0,0,0.55); stroke-width: 2px; }

    /* Temporary link preview while right-dragging to connect */
    .dragline { stroke: var(--accent); stroke-opacity: .8; stroke-width: 2px; stroke-dasharray: 4 3; pointer-events: none; }

    .help { position: absolute; left: 12px; bottom: 12px; background: rgba(0,0,0,0.3); border:1px solid var(--border); padding: .5rem .65rem; border-radius:.6rem; color: var(--muted); font-size: .85rem; backdrop-filter: blur(6px); }
  /* Viewer-only mode: hide editing UI */
    .inspector, .help, #importBtn, #exportBtn, #fileInput, .hint { display: none !important; }
    .inspector { width: 0 !important; padding: 0 !important; border: 0 !important; }
  </style>
</head>
<body>
<div class="app">
  <div class="toolbar">
    <button id="importBtn">Import JSON</button>
    <button id="exportBtn">Export JSON</button>
    <button id="fitBtn">Fit</button>
    <button id="resetBtn">Reset</button>
    <div class="range-group"><label>Size boost</label><input id="boostRange" type="range" min="0" max="100" step="1" value="32"/><span id="boostValue" class="badge">32</span></div><div class="range-group"><label>Spread</label><input id="spreadRange" type="range" min="0.4" max="3.0" step="0.05" value="1.4"/><span id="spreadValue" class="badge">1.4×</span></div>
    <span class="hint">N: new node • Right-drag: connect • Click: select • Drag: move • Scroll: zoom • Drag background: pan</span>
    <input id="fileInput" type="file" accept="application/json" style="display:none" />
  </div>
  <div class="content">
    <div class="graph-wrap" id="graphWrap">
      <svg id="graph" tabindex="0" aria-label="Mind map canvas">
        <defs>
          <!-- Soft glow filter around nodes -->
          <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="3.5" result="blur" />
            <feMerge>
              <feMergeNode in="blur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>
        <g id="zoomLayer">
          <g class="links"></g>
          <g class="nodes"></g>
          <line class="dragline" style="display:none" />
        </g>
      </svg>
      <div class="help">Undirected graph • names must be unique</div>
    </div>

    <aside class="inspector">
      <h3>Inspector</h3>
      <div class="card">
        <div class="row" style="justify-content: space-between;align-items:center;">
          <div class="badge" id="degBadge">degree: 0</div>
          <div class="badge" id="posBadge">x: –, y: –</div>
        </div>
        <div class="field">
          <label for="nameInput">Name</label>
          <input id="nameInput" placeholder="Unique node name" />
        </div>
        <div class="field">
          <label for="notesInput">Notes</label>
          <textarea id="notesInput" placeholder="Free-form notes; URLs allowed"></textarea>
        </div>
        <div class="field">
          <label for="connInput">Links</label>
          <textarea id="connInput" placeholder="Comma-separated neighbor names"></textarea>
        </div>
        <div class="row">
          <button id="applyBtn">Apply</button>
          <div id="err" class="error" style="display:none"></div>
        </div>
      </div>

      <div class="card">
        <div style="font-size:.9rem;color:var(--muted);line-height:1.35;">
          <div><strong>Tips</strong></div>
          <ul style="margin:.4rem 0 .2rem 1rem; padding:0;">
            <li>Press <kbd>N</kbd> to add a node (it spawns near the cluster).</li>
            <li>Right-drag from one node to another to connect.</li>
            <li>Select a node to edit its name and connections.</li>
            <li>Scroll to zoom; drag background to pan.</li>
            <li>Press <kbd>X</kbd> to delete the selected node. Right-click an edge to delete it.</li>
          </ul>
        </div>
      </div>
    </aside>
  </div>
</div>

<script>
(function(){
  const svg = d3.select('#graph');
  const zoomLayer = d3.select('#zoomLayer');
  const linkLayer = d3.select('.links');
  const nodeLayer = d3.select('.nodes');
  const dragline = d3.select('.dragline');
  const graphWrap = document.getElementById('graphWrap');
  const VIEWER_ONLY = true;
  

  // UI elements
  const nameInput = document.getElementById('nameInput');
  const notesInput = document.getElementById('notesInput');
  const connInput = document.getElementById('connInput');
  const applyBtn = document.getElementById('applyBtn');
  const degBadge = document.getElementById('degBadge');
  const posBadge = document.getElementById('posBadge');
  const errEl = document.getElementById('err');

  const importBtn = document.getElementById('importBtn');
  const exportBtn = document.getElementById('exportBtn');
  const fitBtn = document.getElementById('fitBtn');
  const resetBtn = document.getElementById('resetBtn');
  const fileInput = document.getElementById('fileInput');
  const boostRange = document.getElementById('boostRange');
  const boostValue = document.getElementById('boostValue');
  let degreeBoost = +boostRange.value || 32;
  const spreadRange = document.getElementById('spreadRange');
  const spreadValue = document.getElementById('spreadValue');
  let spreadFactor = spreadRange ? +spreadRange.value : 1.0;

  // Data
  /** @type {{id:string, x?:number, y?:number, fx?:number, fy?:number, degree?:number, w?:number, h?:number, collisionRadius?:number, scale?:number, createdAt?:number, notes?:string}[]} */
  let nodes = [];
  /** @type {{source:any, target:any}[]} */
  let links = [];

  // Keep a baseline copy to support Reset in viewer mode
  const baseline = { nodes: [], links: [] };

  let selected = null;         // currently selected node
  let linking = null;          // node we're right-dragging from
  let lastMouse = {x: 0, y: 0}; // track cursor (graph coordinates)
  let selectedLink = null;

  // Center (kept up-to-date on resize)
  let center = {x: 0, y: 0};

  // Scales
  let color = d3.scaleSequential(d3.interpolateCividis).domain([0,1]);

  // Helpers to size rectangles (simple, fast estimate from label length)
  function computeSize(d){
    const baseH = 34; // slightly taller for big degrees
    const padding = 18; // horizontal padding
    const approxChar = 7; // px per character approximation
    const minW = 64; // px
    const deg = d.degree || 0;
    // Stronger, adjustable growth with degree; mild exponent for curvature
    const extra = Math.min(600, Math.pow(deg, 1.3) * degreeBoost);
    const labelW = Math.max(minW, d.id.length * approxChar + padding);
    const w = labelW + extra;
    const scale = w / labelW;
    d.w = w; d.h = baseH * scale; d.scale = scale;
    // collision radius ~ half of diagonal + small gap
    d.collisionRadius = 0.5 * Math.hypot(d.w, d.h);
  }

  function linkDist(l){
    const sum = Math.min(6, (l.source?.degree||0) + (l.target?.degree||0));
    return (40 + sum*2) * Math.pow(spreadFactor || 1, 0.9);
  }
  function chargeStrength(d){
    const N = Math.max(1, nodes.length - 1);
    const deg = d.degree || 0;
    const unlinkedRatio = 1 - (deg / N); // 1 for isolates, ~0 for highly connected
    const base = -120 * (spreadFactor || 1);
    return base * (1 + 0.8 * unlinkedRatio); // stronger repulsion for poorly-connected nodes
  }
  function updateSpread(){
    sim.force('charge').strength(chargeStrength);
    sim.force('x').strength(0.08 / (spreadFactor || 1));
    sim.force('y').strength(0.08 / (spreadFactor || 1));
    sim.force('link').distance(linkDist);
    sim.alpha(0.2).restart();
  }

  // Simulation (tuned for compact layout)
  const sim = d3.forceSimulation(nodes)
    .force('link', d3.forceLink(links)
      .id(d => d.id)
      .distance(linkDist)
      .strength(0.35)
    )
    .force('charge', d3.forceManyBody().strength(chargeStrength)) // milder repulsion to stay compact
    .force('x', d3.forceX(() => center.x).strength(0.08))
    .force('y', d3.forceY(() => center.y).strength(0.08))
    .force('collide', d3.forceCollide().radius(d => (d.collisionRadius || 24) + 6).strength(0.95))
    .alphaDecay(0.05)
    .on('tick', ticked);

  // Resize handling for center force
  function updateCenter() {
    const rect = graphWrap.getBoundingClientRect();
    center.x = rect.width/2;
    center.y = rect.height/2;
    sim.force('center', d3.forceCenter(center.x, center.y)); // keep as gentle anchor
  }
  window.addEventListener('resize', updateCenter);
  updateCenter();
  updateSpread();

  // Zoom behavior (background pan/zoom) — require click-to-focus for wheel zoom
  // Give focus to the SVG when the user clicks/presses inside it
  svg.on('pointerdown', () => { const n = svg.node(); n && n.focus && n.focus(); });
  const zoom = d3.zoom()
    .filter((event) => event.type !== 'wheel' || document.activeElement === svg.node())
    .scaleExtent([0.2, 3])
    .on('zoom', (event) => {
      zoomLayer.attr('transform', event.transform);
    });
  svg.call(zoom);

  // Prevent the default right-click menu over the SVG
  svg.on('contextmenu', (event) => event.preventDefault());

  // Track mouse in graph coordinates
  svg.on('mousemove', (event) => {
    const t = d3.zoomTransform(svg.node());
    let x, y;
    if (typeof event.offsetX === 'number' && typeof event.offsetY === 'number') {
      [x, y] = t.invert([event.offsetX, event.offsetY]);
    } else {
      const rect = svg.node().getBoundingClientRect();
      [x, y] = t.invert([event.clientX - rect.left, event.clientY - rect.top]);
    }
    lastMouse = { x, y };
    if (linking) updateDragline(lastMouse.x, lastMouse.y);
  });

  // Key: N to add node
  if (!VIEWER_ONLY) window.addEventListener('keydown', (e) => {
    if ((e.key === 'n' || e.key === 'N') && !isTyping()) {
      e.preventDefault();
      promptAddNodeNearCluster();
    }
  });
  if (!VIEWER_ONLY) window.addEventListener('keydown', (e) => {
    if ((e.key === 'x' || e.key === 'X') && !isTyping()) {
      if (selected) { e.preventDefault(); deleteNode(selected); }
    }
  });

  // Buttons
  if (!VIEWER_ONLY && importBtn) importBtn.addEventListener('click', () => fileInput && fileInput.click());
  if (!VIEWER_ONLY && fileInput) fileInput.addEventListener('change', onImport);
  if (!VIEWER_ONLY && exportBtn) exportBtn.addEventListener('click', onExport);
  resetBtn.addEventListener('click', () => {
    // Restore baseline graph and refit
    nodes = baseline.nodes.map(n => ({ ...n }));
    links = baseline.links.map(l => ({ ...l }));
    selected = null; linking = null; selectedLink = null;
    // Rebind data to forces before render
    sim.nodes(nodes);
    sim.force('link').id(d => d.id).links(links);
    render();
    restart(0.6);
    fitGraph();
  });
  fitBtn.addEventListener('click', fitGraph);
  if (boostRange){
    boostRange.addEventListener('input', ()=>{
      degreeBoost = +boostRange.value;
      if (boostValue) boostValue.textContent = String(degreeBoost);
      render();
      restart(0.2);
    });
  }
  if (spreadRange){
    spreadFactor = +spreadRange.value || spreadFactor;
    if (spreadValue) spreadValue.textContent = spreadFactor.toFixed(2) + '×';
    spreadRange.addEventListener('input', ()=>{
      spreadFactor = +spreadRange.value;
      if (spreadValue) spreadValue.textContent = spreadFactor.toFixed(2) + '×';
      updateSpread();
    });
  }

  if (!VIEWER_ONLY && applyBtn) applyBtn.addEventListener('click', applyInspectorChanges);
  if (!VIEWER_ONLY && nameInput) nameInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); applyInspectorChanges(); nameInput.blur(); svg.node().focus(); } });
  if (!VIEWER_ONLY && connInput) connInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && (e.metaKey||e.ctrlKey)){e.preventDefault(); applyInspectorChanges(); }});

  function isTyping(){
    const t = document.activeElement?.tagName;
    return t === 'INPUT' || t === 'TEXTAREA' || t === 'SELECT' || document.activeElement?.isContentEditable;
  }

  function clusterCentroid(){
    if (!nodes.length) return {...center};
    let sx=0, sy=0, k=0;
    for (const n of nodes){
      if (Number.isFinite(n.x) && Number.isFinite(n.y)) { sx+=n.x; sy+=n.y; k++; }
    }
    if (!k) return {...center};
    return {x: sx/k, y: sy/k};
  }

  function promptAddNodeNearCluster() {
    // Auto-create node with a random unique name and focus the name input
    let newId;
    do {
      newId = 'Node-' + Math.random().toString(36).slice(2,6);
    } while (findNode(newId));
    const c = clusterCentroid();
    const jitter = () => (Math.random()*2-1) * 30; // spawn close to cluster
    const n = { id: newId, x: c.x + jitter(), y: c.y + jitter(), createdAt: Date.now() };
    nodes.push(n);
    selectNode(n);
    render();
    restart(0.9);
    setTimeout(() => { nameInput.focus(); nameInput.select(); }, 0);
  }

  function selectNode(n) {
    selected = n;
    selectedLink = null;
    updateInspector();
    render();
  }

  function updateInspector(){
    if (!selected) {
      nameInput.value = '';
      connInput.value = '';
      if (notesInput) notesInput.value = '';
      degBadge.textContent = 'degree: 0';
      posBadge.textContent = 'x: –, y: –';
      errEl.style.display='none';
      return;
    }
    nameInput.value = selected.id;
    if (notesInput) notesInput.value = selected.notes || '';
    connInput.value = neighborsOf(selected).join(', ');
    degBadge.textContent = `degree: ${selected.degree || 0}`;
    const x = selected.x?.toFixed(1) ?? '–';
    const y = selected.y?.toFixed(1) ?? '–';
    posBadge.textContent = `x: ${x}, y: ${y}`;
    errEl.style.display='none';
  }

  function applyInspectorChanges(){
    if (!selected) return;

    const newName = nameInput.value.trim();
    const connNames = parseNameList(connInput.value);
    const newNotes = (notesInput?.value || '').trim();

    // Validate name uniqueness
    if (!newName) { return showError('Name cannot be empty.'); }
    if (newName !== selected.id && findNode(newName)) {
      return showError('Duplicate name – choose another.');
    }

    // Rename node
    if (newName !== selected.id) {
      selected.id = newName; // d3.forceLink uses id accessor; we'll reset links below
    }

    selected.notes = newNotes || undefined;

    // Apply connections: make links match exactly the set of names (existing only)
    const existingNames = new Set(nodes.map(n => n.id));
    const validTargets = connNames.filter(nm => existingNames.has(nm) && nm !== selected.id);

    // Remove links not in validTargets
    const want = new Set(validTargets.map(nm => linkKey(selected.id, nm)));
    links = links.filter(l => {
      const s = nodeName(l.source), t = nodeName(l.target);
      const keep = !(s === selected.id || t === selected.id) || want.has(linkKey(s,t));
      return keep;
    });

    // Add missing links
    for (const nm of validTargets) addLink(selected.id, nm);

    // Recompute and refresh
    render();
    restart(0.6);
    updateInspector();
  }

  function parseNameList(str){
    return str.split(/[\n,]+/).map(s => s.trim()).filter(Boolean);
  }

  function showError(msg){ errEl.textContent = msg; errEl.style.display = 'block'; }

  function nodeName(x){ return typeof x === 'string' ? x : x.id; }
  function linkKey(a,b){ return a < b ? `${a}||${b}` : `${b}||${a}`; }

  function hasLink(a,b){
    const key = linkKey(a,b);
    return links.some(l => linkKey(nodeName(l.source), nodeName(l.target)) === key);
  }
  function addLink(a,b){
    if (a === b) return;
    if (hasLink(a,b)) return;
    links.push({ source: a, target: b });
  }
  function deleteNode(node){
    const id = node.id;
    nodes = nodes.filter(n => n !== node);
    links = links.filter(l => nodeName(l.source) !== id && nodeName(l.target) !== id);
    if (selected === node) { selected = null; updateInspector(); }
    render();
    restart(0.4);
  }

  function linkId(d){ return linkKey(nodeName(d.source), nodeName(d.target)); }
  function selectLink(d){ selectedLink = d; selected=null; updateInspector(); render(); }
  function deleteLink(d){ const k = linkId(d); links = links.filter(l => linkId(l) !== k); if (selectedLink && linkId(selectedLink) === k) selectedLink = null; render(); restart(0.3); }

  function neighborsOf(n){
    const nm = n.id;
    const neigh = new Set();
    for (const l of links){
      const s = nodeName(l.source), t = nodeName(l.target);
      if (s === nm) neigh.add(t); else if (t === nm) neigh.add(s);
    }
    return Array.from(neigh).sort();
  }

  function findNode(name){ return nodes.find(n => n.id === name); }

  function recalcDegrees(){
    const deg = new Map(nodes.map(n => [n.id, 0]));
    for (const l of links){
      const s = nodeName(l.source), t = nodeName(l.target);
      if (deg.has(s)) deg.set(s, deg.get(s) + 1);
      if (deg.has(t)) deg.set(t, deg.get(t) + 1);
    }
    let max = 0;
    for (const n of nodes){
      n.degree = deg.get(n.id) || 0;
      if (n.degree > max) max = n.degree;
      computeSize(n);
    }
    color.domain([0, Math.max(1, max)]);
  }

  function render(){
    recalcDegrees();

    // LINKS (main visible lines)
    const linkSel = linkLayer.selectAll('line.link').data(links, d => linkKey(nodeName(d.source), nodeName(d.target)));
    linkSel.exit().remove();
    const linkEnter = linkSel.enter().append('line').attr('class','link')
      .attr('stroke', '#64748b').attr('stroke-opacity', 0.9).attr('stroke-width', 2);
    linkEnter.merge(linkSel)
      .classed('highlight', d => selectedLink && linkId(d) === linkId(selectedLink));

    // LINKS HOT AREA (large hit target for selection/deletion)
    const hotSel = linkLayer.selectAll('line.link-hot').data(links, d => linkKey(nodeName(d.source), nodeName(d.target)));
    hotSel.exit().remove();
    const hotEnter = hotSel.enter().append('line').attr('class','link-hot');
    hotEnter.merge(hotSel)
      .on('click', (event,d)=>{ if (VIEWER_ONLY) return; event.stopPropagation(); selectLink(d); })
      .on('contextmenu', (event,d)=>{ if (VIEWER_ONLY) return; event.preventDefault(); event.stopPropagation(); deleteLink(d); });

    // NODES
    const nodeSel = nodeLayer.selectAll('g.node-g').data(nodes, d => d.id);
    nodeSel.exit().remove();
    const nodeEnter = nodeSel.enter().append('g')
      .attr('class','node-g')
      .on('click', (event, d) => { if (event.button !== 0) return; if (VIEWER_ONLY) return; event.stopPropagation(); selectNode(d); })
      .on('mousedown', (event, d) => {
        // right-button starts linking
        if (VIEWER_ONLY) return;
        if (event.button === 2) { event.stopPropagation(); startLinking(d); }
      })
      .on('mouseup', (event, d) => {
        if (VIEWER_ONLY) return;
        if (event.button === 2) { event.stopPropagation(); finishLinking(d); }
      })
      .on('contextmenu', (event) => { event.preventDefault(); event.stopPropagation(); /* no node delete */ })
      .on('pointerdown', (event) => { event.stopPropagation(); })
      .call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));

    nodeEnter.append('rect')
      .attr('class','node-rect')
      .attr('x', d => -(d.w||30)/2)
      .attr('y', d => -(d.h||20)/2)
      .attr('width', d => d.w||30)
      .attr('height', d => d.h||20)
      .attr('filter', 'url(#glow)');

    nodeEnter.append('text')
      .attr('class','node-label')
      .attr('y', 1)
      .text(d => d.id);

    const nodeMerge = nodeEnter.merge(nodeSel);

    // Ensure dragging is enabled for all nodes (existing and newly entered)
    nodeMerge.call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));

    nodeMerge.select('rect')
      .classed('selected', d => selected && d.id === selected.id)
      .attr('x', d => -(d.w)/2)
      .attr('y', d => -(d.h)/2)
      .attr('width', d => d.w)
      .attr('height', d => d.h)
      .attr('fill', d => color(d.degree || 0))
      .attr('fill-opacity', 0.95);

    nodeMerge.select('text')
      .text(d => d.id)
      .style('font-size', d => Math.max(10, 12 * (d.scale || 1)) + 'px');

    // Wire forces to current data
    sim.nodes(nodes);
    sim.force('link').id(d => d.id).links(links);
    sim.alpha(0.5).restart();
  }

  function ticked(){
    // Link positions
    linkLayer.selectAll('line.link')
      .attr('x1', d => (d.source && Number.isFinite(d.source.x) ? d.source.x : 0))
      .attr('y1', d => (d.source && Number.isFinite(d.source.y) ? d.source.y : 0))
      .attr('x2', d => (d.target && Number.isFinite(d.target.x) ? d.target.x : 0))
      .attr('y2', d => (d.target && Number.isFinite(d.target.y) ? d.target.y : 0));

    linkLayer.selectAll('line.link-hot')
      .attr('x1', d => (d.source && Number.isFinite(d.source.x) ? d.source.x : 0))
      .attr('y1', d => (d.source && Number.isFinite(d.source.y) ? d.source.y : 0))
      .attr('x2', d => (d.target && Number.isFinite(d.target.x) ? d.target.x : 0))
      .attr('y2', d => (d.target && Number.isFinite(d.target.y) ? d.target.y : 0));

    // Node positions
    nodeLayer.selectAll('g.node-g')
      .attr('transform', d => `translate(${d.x},${d.y})`);

    // inspector live position
    if (selected) {
      posBadge.textContent = `x: ${selected.x?.toFixed(1)}, y: ${selected.y?.toFixed(1)}`;
    }
  }

  function restart(alpha=0.6){
    recalcDegrees();
    // Update collide radius (sizes may have changed)
    sim.force('collide').radius(d => (d.collisionRadius || 24) + 6);
    sim.alpha(alpha).restart();
  }

  function dragstarted(event, d){
    if (!event.active) sim.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }
  function dragged(event, d){
    d.fx = event.x;
    d.fy = event.y;
  }
  function dragended(event, d){
    if (!event.active) sim.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }

  // Right-drag linking helpers
  function startLinking(node){
    linking = node;
    dragline.style('display', null)
      .attr('x1', node.x)
      .attr('y1', node.y)
      .attr('x2', node.x)
      .attr('y2', node.y);
  }
  function updateDragline(x, y){
    if (!linking) return;
    dragline.attr('x1', linking.x).attr('y1', linking.y).attr('x2', x).attr('y2', y);
  }
  function finishLinking(target){
    if (!linking) return;
    if (target && target !== linking) {
      addLink(linking.id, target.id);
      render();
      restart(0.6);
    }
    cancelLinking();
  }
  function cancelLinking(){ linking = null; dragline.style('display', 'none'); }

  // Click background to clear selection
  svg.on('click', (e) => { if (e.target === svg.node()) { selected = null; selectedLink = null; updateInspector(); render(); }});

  // Import / Export
  function onExport(){
    // Produce a clean undirected set (no duplicates)
    const uniq = new Set();
    const outLinks = [];
    for (const l of links){
      const a = nodeName(l.source), b = nodeName(l.target);
      const k = linkKey(a,b);
      if (!uniq.has(k)) { uniq.add(k); outLinks.push({ source: a, target: b }); }
    }
    const out = {
      nodes: nodes.map(n => ({ id: n.id, x: n.x, y: n.y, ...(n.notes ? { notes: n.notes } : {}) })),
      links: outLinks
    };
    const blob = new Blob([JSON.stringify(out, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'mindmap.json'; a.click();
    URL.revokeObjectURL(url);
  }

  function normalizeURL(u){ if(!u) return null; const hasScheme = /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(u); return hasScheme ? u : ('https://' + u); }

  function resolveName(v, nodesArr){
    if (typeof v === 'string') return v.trim();
    if (typeof v === 'number') { const idx = Math.floor(v); return nodesArr[idx]?.id || null; }
    if (v && typeof v === 'object') {
      if (typeof v.id === 'string') return v.id.trim();
      if (typeof v.id === 'number') { const idx = Math.floor(v.id); return nodesArr[idx]?.id || null; }
    }
    return null;
  }

  async function onImport(e){
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      const text = await file.text();
      const data = JSON.parse(text);
      if (!Array.isArray(data.nodes) || !Array.isArray(data.links)) throw new Error('Invalid format');
      // Validate duplicates
      const names = data.nodes.map(n => String(n.id).trim());
      const dup = findDuplicates(names);
      if (dup.length){ alert('Duplicate node names in file: ' + dup.join(', ')); return; }
      // Build
      nodes = data.nodes.map(n => {
        const id = String(n.id).trim();
        const x = Number.isFinite(+n.x) ? +n.x : undefined;
        const y = Number.isFinite(+n.y) ? +n.y : undefined;
        return { id, x, y, notes: (typeof n.notes === 'string' && n.notes.trim()) || undefined };
      });
      const existing = new Set(nodes.map(n => n.id));
      links = [];
      const seen = new Set();
      for (const l of data.links){
        const a = resolveName(l.source, nodes), b = resolveName(l.target, nodes);
        if (a === b) continue;
        if (!existing.has(a) || !existing.has(b)) continue;
        const k = linkKey(a,b);
        if (seen.has(k)) continue; seen.add(k);
        links.push({ source: a, target: b });
      }
      selected = null; linking = null; selectedLink = null;
      // Ensure the simulation resolves link endpoints to node objects before first render
      sim.nodes(nodes);
      sim.force('link').id(d => d.id).links(links);
      render();
      restart(0.8);
      // Fit immediately and again after the layout has progressed to ensure correct centering
      fitGraph();
      setTimeout(fitGraph, 120);
      setTimeout(fitGraph, 360);
      sim.on('end', function onceFit(){ fitGraph(); sim.on('end', null); });
    } catch(err){
      console.error(err);
      alert('Failed to import JSON: ' + (err?.message || err));
    } finally {
      fileInput.value = '';
    }
  }

  function findDuplicates(arr){
    const seen = new Set(); const dup = [];
    for (const v of arr){ if (seen.has(v)) dup.push(v); else seen.add(v); }
    return dup;
  }

  // Fit graph into view
  function fitGraph(){
    const bounds = zoomLayer.node().getBBox();
    const parent = svg.node().getBoundingClientRect();
    if (!bounds.width || !bounds.height) return; // nothing to fit
    const fullWidth = parent.width, fullHeight = parent.height;
    const scale = Math.max(0.2, Math.min(2.5, 0.9 / Math.max(bounds.width / fullWidth, bounds.height / fullHeight)));
    const translate = [fullWidth/2 - scale * (bounds.x + bounds.width/2), fullHeight/2 - scale * (bounds.y + bounds.height/2)];
    svg.transition().duration(350).call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
  }

  // --- Smoke tests (dev) ---
  function runSmokeTests(){
    console.assert(typeof ticked === 'function', 'ticked() should exist');
    console.assert(typeof computeSize === 'function', 'computeSize() exists');
    console.assert(typeof linkDist === 'function', 'linkDist() exists');
    console.assert(typeof chargeStrength === 'function', 'chargeStrength() exists');
    console.assert(svg.node() && zoomLayer.node(), 'SVG and layers present');
    console.assert(Array.isArray(nodes) && nodes.length >= 3, 'Seeded 3 nodes');
  }

  // Load graph from external JSON path if provided
  async function loadExternalJSON(path){
    try {
      const resp = await fetch(path, { cache: 'no-store' });
      if (!resp.ok) throw new Error('HTTP ' + resp.status);
      const text = await resp.text();
      const data = JSON.parse(text);
      if (!Array.isArray(data.nodes) || !Array.isArray(data.links)) throw new Error('Invalid format');
      const names = data.nodes.map(n => String(n.id).trim());
      const dup = findDuplicates(names);
      if (dup.length){ console.warn('Duplicate node names in file:', dup.join(', ')); }
      nodes = data.nodes.map(n => {
        const id = String(n.id).trim();
        const x = Number.isFinite(+n.x) ? +n.x : undefined;
        const y = Number.isFinite(+n.y) ? +n.y : undefined;
        return { id, x, y, notes: (typeof n.notes === 'string' && n.notes.trim()) || undefined };
      });
      const existing = new Set(nodes.map(n => n.id));
      links = [];
      const seen = new Set();
      for (const l of data.links){
        const a = resolveName(l.source, nodes), b = resolveName(l.target, nodes);
        if (a === b) continue;
        if (!existing.has(a) || !existing.has(b)) continue;
        const k = linkKey(a,b);
        if (seen.has(k)) continue; seen.add(k);
        links.push({ source: a, target: b });
      }
      selected = null; linking = null; selectedLink = null;
      sim.nodes(nodes);
      sim.force('link').id(d => d.id).links(links);
      render();
      restart(0.8);
      // Set baseline to this loaded graph so Reset restores it
      baseline.nodes = nodes.map(n => ({ ...n }));
      baseline.links = links.map(l => ({ source: typeof l.source === 'string' ? l.source : l.source.id, target: typeof l.target === 'string' ? l.target : l.target.id }));
      fitGraph();
      setTimeout(fitGraph, 120);
      setTimeout(fitGraph, 360);
      sim.on('end', function onceFit(){ fitGraph(); sim.on('end', null); });
    } catch (err) {
      console.error('Failed to load external JSON from', path, err);
    }
  }

  // Bootstrap: prefer external JSON path via global var; else seed default
  (async function boot(){
    const qs = new URLSearchParams(location.search);
    const qsJson = qs.get('json');
    // If the query string provides ?json=..., mirror it into the legacy/global var
    // so hosts that expect window.MINDMAP_PATH_JSON still work.
    if (qsJson) {
      window.MINDMAP_PATH_JSON = qsJson;
    }
    const path = qsJson || window.MINDMAP_PATH_JSON || window.MINDMAP_JSON_PATH || window.MAP_JSON_PATH || window.MINDMAP_JSON_URL || null;
    if (path) {
      await loadExternalJSON(path);
      return;
    }
    // Seed with a tiny example so the canvas isn’t empty
    const a = {id:'Idea'}, b = {id:'Research'}, c = {id:'Notes'};
    nodes.push(a,b,c);
    links.push({source:'Idea', target:'Research'}, {source:'Research', target:'Notes'});
    render();
    restart(0.8);
    // Capture baseline after initial seed so Reset can restore it
    baseline.nodes = nodes.map(n => ({ ...n }));
    baseline.links = links.map(l => ({ source: typeof l.source === 'string' ? l.source : l.source.id, target: typeof l.target === 'string' ? l.target : l.target.id }));
    runSmokeTests();
  })();
})();
</script>
</body>
</html>
